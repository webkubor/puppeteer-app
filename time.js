
/*
*  事件循环机制
*  Node.js 启动后会初始化事件轮询，过程中可能处理异步调用、定时器调度和 process.nextTick()，然后开始处理event loop
*┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │

* */

/******************  macroTask 分割线 ********************/
setImmediate(console.log, 1);
setTimeout(console.log, 1, 2);
/****************** microTask 分割线 ********************/
Promise.resolve(3).then(console.log);
/******************异步操作都被放到了下一个 event loop tick 中，process.nextTick 在进入下一次
 *  event loop tick 之前执行，所以肯定在其它异步操作之前 下次 event loop tick 分割线 ********************/
process.nextTick(console.log, 4);
/****************** 同步任务和异步任务的分割线 ********************/
console.log(5);

/****************** 输出：5，4，3，2，1 ********************/
